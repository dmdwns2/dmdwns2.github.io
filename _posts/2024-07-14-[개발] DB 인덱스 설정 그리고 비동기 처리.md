---
layout: post
title: (서버/일상) DB 인덱스 설정 그리고 비동기 처리
header: (서버/일상) DB 인덱스 설정 그리고 비동기 처리
duration: 12 minutes read
ogimage: "img/favicon.png"
published: true
date: 2024-07-14
categories: ["Server"]
---
### 성능 개선이 재밌는 사람
수습기간 중에 회사 웹서버의 성능을 개선하는 것에 재미를 느껴서 굳이 누가 시키지 않더라도 재밌게 한 것 같습니다.
그 중에서 6월 중에 진행한 두 가지를 소개시켜 드리려고 합니다.


### DB 인덱스 설정

회사 웹페이지에서 특정 조회가 오래 걸리길래 해당 문제를 해결하라는 작업을 받았습니다. 
Mysql 을 사용하고 있기 때문에 EXPLAIN 으로 실행 계획을 살펴보면서 원인을 분석했고 특정 로우와 다른 로우를 병합해서 조회하는 쿼리였는데
뭐가 문제인지 보니 인덱스 설정이 안되어있었습니다.
그래서 인덱스 설정을 해줬더니 몇 십초 걸리던 조회가 0.03초에 끝나게 되었습니다.
보고 후 회사 DB에 전체적으로 인덱스 설정을 해달라는 작업요청을 받았습니다. 그래서 취준 시절에 공부했던 MySQL 8.0 책을 가져와서
어떻게 짜야 제대로 짤 수 있을지 고민을 했고, 다양한 블로그도 참고했습니다.
이론적으로만 알고있던 지식이어서 실제로 전체 DB에 적용하는 작업은 상당히 조심스러웠기 때문에 최대한 정확하게 알고 설정하는 식으로
하기 위해 열심히 공부한 다음 업무에 임했습니다. 

1. 기준 정하기 : 인덱스 설계 기준을 만드는 작업을 했습니다. 책과 블로그를 보면서 기준을 명확하게 잡기 시작했고 다른 블로그의 경험을
토대로 최대한 실속있게 적용하는 것을 목표로 했습니다. 
2. 하면 안되는 것들 파악하기 : 아무래도 신입이다보니 정확하게 작성하는 것도 중요하지만 하면 안되는 것을 하지않는 게 더 중요합니다.
그래서 다른 블로그들을 보면서 DB에 하면 안되는 경험담들을 보면서 이런 것들은 피하는게 좋구나 알고 진행했습니다.
3. 적용하기 : 모든 테이블을 다 돌면서 컬럼 하나하나에 기준들을 가져다 대서 판단을 하는 방식으로 진행했습니다. 모든 컬럼을 보아야 하기 때문에
오래걸릴 줄 알았는데 기준이 점점 익숙해지면서 판단 속도가 빨라지고, 기계처럼 인덱스 적합/ 부적합 기준을 따지게 되어서 나름 빠르게 진행할 수 있었습니다.
4. 테스트 : 인덱스를 적용하고 실제로 속도가 빨라지는지 테스트 해봤습니다. 확실히 기존 보다는 빠른 방식으로 조회가 이루어졌습니다.
5. 배포 : 배포는 어떻게 해야할지 고민하고 있었는데 이 부분은 팀장님께서 처리해 주셨습니다. ANSIBLE을 사용해서 모든 서버에 자동적으로 서버 설정을 업데이트 하는 
방식이 있었고, 덕분에 ANSIBLE에 대해 공부할 수 있었습니다.

위와 같은 방식으로 진행했고, 원래는 몇 억 개의 데이터 단위를 줄이는 게 목표긴 한데 회사에는 그정도 양의 데이터 테이블은 없어서
더 깎고 깎은 최적화를 해보고 싶었는데 뭔가 김샌 느낌으로 아쉽게 끝나긴 했습니다. 그래도 몇 십초 -> 0.03초까진 개선할 수 있었습니다.

---

### 비동기 처리 방식

이건 누가 시킨게 아니고 그냥 개인적으로 재밌어 보여서 시도했습니다. 하나의 서버에서 다른 서버들에 sftp 연결을 하는 방식이 있는데
이 방식을 반복문을 통해 하나 연결하고 데이터 가져오고 닫고 다음서버 연결하고 데이터 가져오고 닫고... 이런방식으로 진행되고 있다는 걸 알았습니다.
sftp 연결은 서버 하나당 약 1초정도 걸리는데 이 작업을 여러번 하다보니 시간이 오래 걸리는 문제였습니다.
그래서 어떻게 해야 빠르게 처리할 수 있을 지 고민하다가 sftp 연결을 비동기 방식으로 처리하는게 어떨까 생각하게 되었습니다.
이것도 지식으로만 알았지 실제로 적용하는 건 처음이라 더 재밌게 했던 것 같습니다.

처음엔 어떤 방식으로 해야할지 찾아보니 Reactive stack(리액트는 회사에서 안씀), ExecutorService, CompletableFuture 를 주로 사용한다는 것을 알게 되었습니다.
하지만 왜인지 이 방식을 적용했더니 Bean관련 에러가 발생했습니다. 항상 느끼는 거지만 회사의 스프링 버전이 낮다는 걸 항상 염두해두고
작업에 임해야 하기 때문에 스프링 관련 문제가 제 지식 밖에서 발생하게되면 어떻게든 그 방식을 적용하는 것 보다 다른 방식을 찾게 되는 것 같습니다.
원인이 CompletableFuture 임을 알았지만 할 수 있는게 없어서 스프링에서 제공하는 @Async 애노테이션과 AsyncConfig 클래스를 추가했습니다.

일단 비동기는 잘 동작하는 것을 테스트코드를 통해 확인할 수 있었지만 제가 적용하고 싶은 메서드에서는 동작을 하지 않았습니다.
그래서 해당 메서드에서 디버깅을 진행하니 프레임워크에서 에러를 뱉었습니다. 'Future 를 꼭 사용해야 하나?' 싶어서 
어떻게든 다시 해보려고 노력 했지만 다음과 같은 에러가 발생했습니다.
저는 생성자 주입으로 AsyncService 의 의존성을 주입했는데 이게 CGLIB 관련 에러가 발생하면서 빈 등록이 제대로 되지 않았습니다.
그래서 스프링 버전이 낮아서 그렇구나 하고 필드주입으로 바꿨더니 제대로 동작을 했습니다.
아 그런데 저는 아무리 버전의 한계에 부딪힌다고 해도 최대한 합의점을 제가 원하는 쪽으로 가져오고 싶었고 생성자 주입을 사용하면서도
CGLIB 에러가 발생하지 않는 방식을 생각해보다가 그냥 AsyncService를 인터페이스로 만들면 되는거 아닌가? 싶어서 인터페이스와 구현체로 다시 작성하고
인터페이스를 생성자 주입 했더니 이 문제는 해결되었습니다.
+) 스프링 3.x 이하 버전에서 CGLIB proxy 사용시 발생하는 문제라고 하는데, 같은 문제가 발생하는 분은 인터페이스로 주입을 해보시길 바랍니다.

그 다음은 비동기로 바뀐 메서드에서 값을 for문에서 비동기로 ArrayList에 집어넣어야 하는데 이 방식을 기다릴 수 있는 방법이
CompletableFuture를 사용하지 않고서는 직접 구현해야 한다는 것을 알았고, 저는 Thread.sleep과 전에 했던 데이터 변경감지때 만들었던 알고리즘 로직을 접목해서
해결할 수 있었습니다.

이렇게 이번에도 연결되는 서버가 많아지면 많아질수록 서버당 +1초씩 늘어나는 현상을 병렬로 처리해서 3~4초에 끝낼 수 있었습니다.

---

### 요즘 느끼는 것들

그냥 단순 업무 보다는 찾아서 하는 이런 성능 개선이 훨씬 재밌는 것 같습니다. 근데 너무 빨리 많은 부분을 개선한 것 같아서 이제 더이상
속도를 높이는 일이 많이 남지 않았네요 이 부분은 아쉽습니다. 그리고 이렇게 개선 작업도 하루 이틀에 끝낼 수 있는게 아닌
진짜 수 억단위 혹은 정말 복잡하게 얽힌 것들에서의 최적화같이 디테일을 쪼개고 쪼개면서 문제와 디테일 싸움으로 가는 걸 되게 좋아하는데
이런 경험을 할 수 없다는 것은 아쉽습니다... 물론 어디서나 쉽게 할 수 있는 경험이 아닌 것은 압니다.

그리고 이건 잡담인데 요새 가장 중요하다고 느끼는게 최대한 살면서 감각을 다양하게 써보고 싶다는 생각이 드네요
예를 들면 다양한 와인, 위스키, 디퓨저, 향수의 향을 맡아보면서 후각을 더 깨운다던지, 평소에 잘 안먹는 음식들을 먹으면서 
예를들면 단순히 고수만 먹어본다던지, 이 후 피쉬소스와 섞어서 먹어본다던지 등 미각을 다양하게 써보는 것들.
이런 것들이 제 기준엔 삶의 질에 굉장히 중요하다고 생각이 들었습니다. 서울로 오니 이런 경험을 쌓을 공간도 많고, 거리도 가깝다고 느껴져서 참 좋습니다.
암튼 이런 소소하지만 처음 겪는 경험들이 굉장히 중요하다고 생각해서 경험을 쌓고 있습니다.

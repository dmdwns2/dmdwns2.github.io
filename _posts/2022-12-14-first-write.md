---
title:          "[알고리즘] Optimal Strategy"
description:    "DP를 이용한 Optimal Strategy에 관한 포스트"
date:           2022-12-14
permalink:      
layout: post
tag: 
---

<style>
img {
    width: 120px;
    margin: 3rem auto 0 auto;
}
p.pic {
    margin: auto;
    margin-bottom: 2rem;
    text-align: center;
    font-size: 0.75rem;
}
</style>

## 최적의 전략(Optimal Strategy) 찾기

다이내믹 프로그래밍 방법을 이용해 풀 수 있는 대표적인 문제를 한가지 더 풀어보겠습니다. 간단한 게임에서 항상 이기는 알고리즘 입니다. 아래 문제를 먼저 보겠습니다.

문제

list = [2, 7, 40, 19, 4, 9]

위 배열과 같이 짝수개의 숫자 카드가 일렬로 놓여있습니다. 

나와 상대방이 번갈아 가면서 카드를 가지고 올 수 있는데 현재 놓여있는 카드 중에서 맨 앞에 있는 카드 또는 맨 뒤에 있는 카드를 가지고 올 수 있습니다.

예를들어 [2, 7, 40, 19, 4, 9] 카드가 있다면 카드를 가지고 올 때 맨 앞에 있는 2 또는 맨 뒤에 있는 9를 가지고 올 수 있습니다. 처음부터 40이나 19를 가지고 올 수는 없습니다.

[2, 7, 40, 19, 4, 9]여기에서 9를 가지고 왔다면 상대방은 [2, 7, 40, 19, 4] 중 2와 4를 가지고 갈 수 있습니다.

이 게임은 가지고온 카드의 숫자 총 합이 많은 사람이 이기는 게임입니다.

내가 먼저 카드를 가지고 올 수 있을 때. 이 게임에서 항상 승리 할 수 있는 알고리즘을 만들어 보세요. 여기에서 상대방은 단순히 남아있는 숫자 중 큰 숫자를 가지고 가는 것이 아니라 그 순간에 최적의 선택을 합니다.

---

숫자가 써있는 동전이 1개만 있는 경우

|  | 2 | 7 | 40 | 19 |
| --- | --- | --- | --- | --- |
| 0 |  |  |  |  |
| 1 |  |  |  |  |
| 2 |  |  |  |  |
| 3 |  |  |  |  |

[2, 7, 40, 19] 숫자가 이렇게 4개가 있지만 2만 있다고 해보겠습니다. 그러면 플레이어가 나와 상대방 두명이 있지만 내가 항상 먼저 하는 선이기 때문에 내가 먼저 하나만 있는 2를 가지고 올 수 있습니다.

2만 있을 때

|  | 2 | 7 | 40 | 19 |
| --- | --- | --- | --- | --- |
| 0 | (2 |  |  |  |
| 1 |  |  |  |  |
| 2 |  |  |  |  |
| 3 |  |  |  |  |

상대방은 가져올게 없기 때문에 0입니다.

|  | 1 | 2 | 3 | 4 |
| --- | --- | --- | --- | --- |
| 1 | (2, 0) |  |  |  |
| 2 |  |  |  |  |
| 3 |  |  |  |  |
| 4 |  |  |  |  |

이렇게 해서 2만 한개 있을때의 최적의 선택은 내가 2를 가지고 오고 상대방은 가지고 온 숫자가 없기 때문에 0이 되고 내가 승리를 합니다.

이제는 [2, 7, 40, 19] 중에 2번째 숫자인 7만 있다고 가정을 해보겠습니다.

|  | 2 | 7 | 40 | 19 |
| --- | --- | --- | --- | --- |
| 0 | (2, 0) |  |  |  |
| 1 |  | (7,0) |  |  |
| 2 |  |  |  |  |
| 3 |  |  |  |  |

두번째 숫자이기 때문에 2번째 줄, 2번째 칸에 적겠습니다.

|  | 1 | 2 | 3 | 4 |
| --- | --- | --- | --- | --- |
| 1 | (2, 0) |  |  |  |
| 2 |  | (7, 0) |  |  |
| 3 |  |  |  |  |
| 4 |  |  |  |  |

역시나 숫자는 두번째 숫자인 7 한개밖에 없기 때문에 상대방은 가지고 올 숫자가 없습니다. 그래서 0입니다. 그러면 위와 같이 2행 2열에 (7, 0)이 기록이 되겠습니다.

[2, 7, 40, 19]

|  | 2 | 7 | 40 | 19 |
| --- | --- | --- | --- | --- |
| 0 | (2, 0)              |  |  |  |
| 1 |  | (7, 0)               |  |  |
| 2 |  |  | (40, 0)            |  |
| 3 |  |  |  | (19, 0)             |

계속해서 3번째 숫자, 4번째 숫자만 있다고 가정 했을 때 3,3에는 (40, 0) 4, 4에는 (19, 0)이 각각 들어가게 됩니다.

```java
class Pair1{
   int left;
   int right;
   public Pair1(int left, int right) {
       this.left = left;
       this.right = right;
   }

   @Override
   public String toString() {
       return "Pair1{" +
               "left=" + left +
               ", right=" + right +
               '}';
   }
}

public class OptimalStrategy2 {
   public static void main(String[] args) {
       int[] coins = {2, 7, 40, 19};

       // 4 * 4 배열
       Pair1[][] dp = new Pair1[coins.length][coins.length];

       // 숫자가 써있는 동전이 1개만 있는 경우
       // 2 or 7 or 40 or 19
       for (int i = 0; i < coins.length; i++) {
           //0,0 1,1 2,2 3,3
           // 내가 왼쪽
           dp[i][i] = new Pair1(coins[i], 0);
       }

       for (int i = 0; i < coins.length; i++) {
           System.out.println(dp[i][i].toString());
       }
   }
}
```

숫자가 써있는 동전이 2개만 있는 경우

[2, 7,,], [,7,40,], [,,40, 19]

[2,  7, 40, 19]

0,1

| 2 | 7 |  |  |
| --- | --- | --- | --- |

1,2

|  | 7 | 40 |  |
| --- | --- | --- | --- |

2,3

|  |  | 40 | 19 |
| --- | --- | --- | --- |

|  | 2 | 7 | 40 | 19 |
| --- | --- | --- | --- | --- |
| 0 | (2, 0) | (7, 2)                |  |  |
| 1 |  | (7, 0) | (40, 7)             |  |
| 2 |  |  | (40, 0) | (40, 19)             |
| 3 |  |  |  | (19, 0) |

fori → i = 0, 1, 2

2개의 숫자만 있는 경우2

[2, 7]

[2, 7]만 있는 경우 Math.max(2, 7)을 내가 가지고 옵니다.

상대방은 2만 남겨지기 때문에 2를 가져갈 수 밖에 없습니다. 이 상황은 상대방 입장에서는 보라색칸 입니다.

|  | 2 | 7 | 40 | 19 |
| --- | --- | --- | --- | --- |
| 0 | (2, 0)                 |                           |  |  |
| 1 |  | (7, 0) |                           |  |
| 2 |  |  | (40, 0) |                           |
| 3 |  |  |  | (19, 0) |

```java
class Pair1{
    int left;
    int right;
    public Pair1(int left, int right) {
        this.left = left;
        this.right = right;
    }

    @Override
    public String toString() {
        return "Pair1{" +
                "left=" + left +
                ", right=" + right +
                '}';
    }
}

public class OptimalStrategy2 {
    public static void main(String[] args) {
        int[] coins = {2, 7, 40, 19};

        // 4 * 4 배열
        Pair1[][] dp = new Pair1[coins.length][coins.length];

				// 숫자가 써있는 동전이 1개만 있는 경우
        // 2 or 7 or 40 or 19
        for (int i = 0; i < coins.length; i++) {
            //0,0 1,1 2,2 3,3
            // 내가 왼쪽
            dp[i][i] = new Pair1(coins[i], 0);
        }

        // 숫자가 써있는 동전이 2개만 있는 경우
        for (int i = 0; i < coins.length -1 ; i++){
            System.out.printf("%d %d %d %d\n", i, i+1, coins[i], coins[i+1]);
            int left = Math.max(coins[i], coins[i+1]);
            int right = Math.min(coins[i], coins[i+1]);
            dp[i][i+1] = new Pair1(left,right);
            System.out.println(dp[i][i+1].toString());
        }

    }
}
```

결과
0 1 2 7
Pair1{left=7, right=2}
1 2 7 40
Pair1{left=40, right=7}
2 3 40 19
Pair1{left=40, right=19}

3개의 숫자만 있는 경우

[2, 7, 40], [7,40,19]

[2, 7, 40]에서 40을 가지고 오는 경우 [2, 7]만 있는 경우에서 작은 쪽을 내가 가지고 오게 됩니다.

[7,40,19]에서 가지고 올 수 있는 가장 큰 수인 19를 가지고 오면 상대방은 7, 40이 있는 경우에서 큰 숫자인 40을 가져가고 나는 작은 숫자인 7을 가지고 오게 됩니다.

|  | 2 | 7 | 40 | 19 |
| --- | --- | --- | --- | --- |
| 0 | (2, 0)                |                           |                           |  |
| 1 |  | (7, 0)                 |                           |                           |
| 2 |  |  | (40, 0)              |                           |
| 3 |  |  |  | (19, 0)              |

4개의 숫자가 모두 있는 경우

[2, 7, 40, 19]

|  | 2 | 7 | 40 | 19 |
| --- | --- | --- | --- | --- |
| 0 | (2, 0)                |                           |                           |                           |
| 1 |  | (7, 0)                 |                           |                           |
| 2 |  |  | (40, 0)              |                           |
| 3 |  |  |  | (19, 0)              |

---


1.LCS
2.Min Cost
3.Optimal Strategy

0번 idx부터 2번 idx까지
[2, 7, 40]
7, 2




40, 7


내가 40을 선택하면 상대방이 2, 7중에 최적 선택을 하는 경우와 같습니다. 그러므로 왼쪽칸 7, 2의 두번재 값을 내가 가지고 와야 합니다. 그래서 40+2 = 42가 됩니다.

내가 2를 선택하면 상대방이 40, 7중에 최적 선택을 하는 경우와 같습니다. 그러므로 아래칸 40, 7의 두번재 값을 내가 가지고 와야 합니다. 그래서 2 + 7 = 9가 됩니다.

Math.max(coins의 right + dp[i][j-1].right, coins의 left + dp[i+1][j].right);


1번 idx부터 3번 idx까지
[7, 40, 19]

내가 19를 선택하면 상대방이 7, 40중에 최적 선택을 하는 경우와 같습니다. 그러므로 왼쪽칸 40, 7의 두번재 값을 내가 가지고 와야 합니다. 그래서 19+7 = 26이 됩니다.

내가 7을 선택하면 상대방이 40, 19중에 최적 선택을 하는 경우와 같습니다. 그러므로 아래칸 40, 19의 두번재 값을 내가 가지고 와야 합니다. 그래서 7+19 = 26이 됩니다.

Math.max(coins의 right + dp[i][j-1].right, coins의 left + dp[i+1][j].right);

40,7

40,19


왼쪽과 오른쪽 저장하기
Optimal Strategy에서 왼쪽과 오른쪽을 정하는 로직 또한 까다롭습니다.
[2, 7, 40, 19]
2,7
7,40
40,19

i, j i는 1개씩 늘고 j도 i따라 늘고

i = 1일때 j가 i만큼 늘어난다면
0,1
1,2
2,3

i = 2일때 j가 i만큼 늘어난다면
0, 2
1, 3




ex) for i { for j } 는 안됨
0 0
0 1
0 2
1 0
1 1
1 2


(idx)
2
(0)
7
(1)
40
(2)
19
(3)
0
2
2, 7
2,40
2, 19
1

7
7,40
7,19
2


40
40,19
3

19

보라색칸의 인덱스는 0, 2

j + i → 오른쪽
